<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Manipulating Data with SQL</title>
    <link href="../../../../static/favicon.png" rel="icon" />
    <link href="../../../../static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="../../../../static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="../../../../static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="../../../../static/internal.css" rel="stylesheet" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="../../../../static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">java.jdbc API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">JDBC-based SQL Interface</span> <span id="version">0.3.0</span> API</span><br />
    <ul>
      <li><a class="wiki_link" href="../../../../index.html">Overview</a></li>
      <li><a class="wiki_link" href="../../../../api-index.html">API Index</a></li>
    </ul>
    
    
    <a href="../../../../http://clojure.org" class="wiki_link">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"></div>
                <div id="content-tag"><html><body><p><em>Note: this documentation will soon move to <a href="http://clojure-doc.org">clojure-doc.org</a> where it can be more easily maintained and accept community contributions.</em></p>

<h1>Manipulating Data with SQL</h1>

<p>Here are some examples of using clojure.java.jdbc to manipulate data with SQL.
These examples assume a simple table called fruit (see <a href="https://github.com/clojure/java.jdbc/blob/master/doc/clojure/java/jdbc/UsingDDL.md">Manipulating Tables with DDL</a>).</p>

<h2>Inserting multiple rows</h2>

<p>If you want to insert complete rows, you can use <em>insert!</em> and provide the values as a simple vector for each row. Every column's value must be present in the same order the columns are declared in the table. This performs a series of insert statement. If you attempt to insert a single row, a map of the generated keys will be returned.</p>

<pre><code>(defn insert-rows-fruit
  "Insert complete rows"
  [db]
  (j/insert! db
    :fruit
    nil ; column names not supplied
    [1 "Apple" "red" 59 87]
    [2 "Banana" "yellow" 29 92.2]
    [3 "Peach" "fuzzy" 139 90.0]
    [4 "Orange" "juicy" 89 88.6]))
;; (1 1 1 1) - row counts modified
</code></pre>

<h2>Inserting partial rows</h2>

<p>If you want to insert rows but only specify some columns' values, you can use <em>insert!</em> and provide the names of the columns following by vectors containing values for those columns. This performs a single insert statement. If you attempt to insert a single row, a map of the generated keys will be returned.</p>

<pre><code>(defn insert-values-fruit
  "Insert rows with values for only specific columns"
  [db]
  (j/insert! db
    :fruit
    [:name :cost]
    ["Mango" 722]
    ["Feijoa" 441]))
</code></pre>

<h2>Inserting a record</h2>

<p>If you want to insert a single record, you can use <em>insert!</em> and specify the columns and their values as a map. This performs a single insert statement. A map of the generated keys will be returned.</p>

<pre><code>(defn insert-record-fruit
  "Insert a single record, map from keys specifying columsn to values"
  [db]
  (j/insert! db
    :fruit
    {:name "Pear" :appearance "green" :cost 99}))
</code></pre>

<h2>Inserting multiple records</h2>

<p>If you want to insert multiple records, you can use <em>insert!</em> and specify each record as a map of columns and their values. This performs a separate insert statement for each record. The generated keys are returned in a sequence of maps.</p>

<pre><code>(defn insert-records-fruit
  "Insert records, maps from keys specifying columns to values"
  [db]
  (j/insert! db
    :fruit
    {:name "Pomegranate" :appearance "fresh" :cost 585}
    {:name "Kiwifruit" :grade 93}))
</code></pre>

<h2>Using transactions</h2>

<p>You can write multiple operations in a transaction to ensure they are either all performed, or all rolled back.</p>

<pre><code>(defn db-write
  "Write initial values to the database as a transaction"
  [db]
  (j/db-transaction [t-con db]
    (insert-rows-fruit t-con)
    (insert-values-fruit t-con)
    (insert-records-fruit t-con)))
</code></pre>

<p>The <em>db-transaction</em> macro creates a transaction-aware connection from the database specification and that should be used in the body of the transaction code.</p>

<h2>Reading and processing rows</h2>

<p>To execute code against each row in a result set, use <em>query</em> with SQL.</p>

<pre><code>(defn db-read
  "Read the entire fruit table"
  [db]
  (j/query db
    ["SELECT * FROM fruit"]
    :row-fn println))

(defn db-read-all
  "Return all the rows of the fruit table as a vector"
  [db]
  (j/query db
    ["SELECT * FROM fruit"]
    :as-arrays? true))

;; ([:id :name :appearance :cost :grade]
;;  [1 "Apple" "red" 59 87.0]
;;  [2 "Banana" "yellow" 29 92.2]
;;  ...)

(defn db-grade-range
  "Print rows describing fruit that are within a grade range"
  [db min max]
  (j/query db
    [(str "SELECT name, cost, grade "
          "FROM fruit "
          "WHERE grade &gt;= ? AND grade &lt;= ?")
     min max]
    :row-fn println))

(defn db-grade-a 
  "Print rows describing all grade a fruit (grade between 90 and 100)"
  [db]
  (db-grade-range db 90 100))
</code></pre>

<h2>Updating values across a table</h2>

<p>To update column values based on a SQL predicate, use <em>update!</em> with a SQL where clause and a map of columns to new values. The result is a sequence of update counts, indicating the number of records affected by each update (in this case, a single update and therefore a single count in the sequence).</p>

<pre><code>(defn db-update-appearance-cost
  "Update the appearance and cost of the named fruit"
  [db name appearance cost]
  (j/update! mysql-db
   :fruit
   {:appearance appearance :cost cost}
   ["name=?" name]))

(defn db-update
  "Update two fruits as a transaction"
  [db]
  (j/db-transaction [t-con db]
    (db-update-appearance-cost t-con "Banana" "bruised" 14)
    (db-update-appearance-cost t-con "Feijoa" "green" 400)))
</code></pre>

<h2>Updating values or Inserting records conditionally</h2>

<p>If you want to update existing records that match a SQL predicate or insert a new record if no existing records match, you can use a transaction wrapped around an <em>update!</em> and a conditional <em>insert!</em>.
use <em>update-or-insert-values</em> with a SQL where clause and a map of columns to values. This calls <em>update-values</em> first and if no rows were updated, this calls <em>insert-values</em>. The result is either the sequence of update counts from the update or the sequence of generated key maps from the insert.</p>

<pre><code>(defn db-update-or-insert
  "Updates or inserts a fruit"
  [db record where-clause]
  (j/db-transaction [t-con db]
    (let [result (j/update! t-con :fruit record where-clause)]
      (if (zero? (first result))
        (j/insert! t-con :fruit record)
        result))))

(db-update-or-insert mysql-db
  {:name "Cactus" :appearance "Spiky" :cost 2000}
  ["name = ?" "Cactus"])
;; inserts Cactus
(db-update-or-insert mysql-db
  {:name "Cactus" :appearance "Spiky" :cost 2500}
  ["name = ?" "Cactus"])
;; updates the Cactus we just inserted
</code></pre>

<h2>Exception Handling and Transaction Rollback</h2>

<p>Transactions are rolled back if an exception is thrown, as shown in these examples.</p>

<pre><code>(defn db-exception
  "Demonstrate rolling back a partially completed transaction on exception"
  [db]
  (j/db-transaction [t-con db]
    (j/insert! t-con
      :fruit
      [:name :appearance]
      ["Grape" "yummy"]
      ["Pear" "bruised"])
    ;; at this point the insert-values call is complete, but the transaction
    ;; is not. the exception will cause it to roll back leaving the database
    ;; untouched.
    (throw (Exception. "sql/test exception")))))
</code></pre>

<p>Transactions can also be set explicitly to rollback instead of commit:</p>

<pre><code>(defn db-rollback
  "Demonstrate a rollback-only trasaction"
  [db]
  (j/db-transaction [t-con db]
    (prn "is-rollback-only" (j/db-is-rollback-only t-con))
    (j/db-set-rollback-only! t-con)
    (j/insert! t-con
      :fruit
      [:name :appearance]
      ["Grape" "yummy"]
      ["Pear" "bruised"])
     (prn "is-rollback-only" (j/db-is-rollback-only t-con))
     (j/query t-con
       ["SELECT * FROM fruit"]
       :row-fn println))
    (prn)
    (j/query db
      ["SELECT * FROM fruit"]
      :row-fn println))
</code></pre>
</body></html></div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">Copyright 2007-2013 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>